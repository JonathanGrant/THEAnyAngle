// Generated by CoffeeScript 1.10.0
(function() {
  var AStarSearch, EuclideanDistance, Grid, Point, goal, grid, i, len, path, point, searchie, square, start;

  Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.North = null;

    Point.NorthWest = null;

    Point.NorthEast = null;

    Point.East = null;

    Point.West = null;

    Point.South = null;

    Point.SouthWest = null;

    Point.SouthEast = null;

    Point.fVal = 999999999999999999;

    Point.gVal = 999999999999999999;

    Point.hVal = 999999999999999999;

    Point.Parent = null;

    Point.prototype.getSuccessors = function() {
      var successors;
      successors = [];
      if (this.North) {
        successors.push(this.North);
      }
      if (this.NorthWest) {
        successors.push(this.NorthWest);
      }
      if (this.NorthEast) {
        successors.push(this.NorthEast);
      }
      if (this.West) {
        successors.push(this.West);
      }
      if (this.East) {
        successors.push(this.East);
      }
      if (this.SouthWest) {
        successors.push(this.SouthWest);
      }
      if (this.SouthEast) {
        successors.push(this.SouthEast);
      }
      if (this.South) {
        successors.push(this.South);
      }
      return successors;
    };

    return Point;

  })();

  Grid = (function() {
    function Grid(width, height) {
      this.Width = width;
      this.Height = height;
      this.Points = [];
    }

    Grid.prototype.createEmptyGrid = function() {
      var Row, col, i, j, k, l, len, len1, point, points, ref, ref1, ref2, row;
      for (row = i = 0, ref = this.Width; 0 <= ref ? i < ref : i > ref; row = 0 <= ref ? ++i : --i) {
        Row = [];
        for (col = j = 0, ref1 = this.Height; 0 <= ref1 ? j < ref1 : j > ref1; col = 0 <= ref1 ? ++j : --j) {
          Row.push(new Point(row, col));
        }
        this.Points.push(Row);
      }
      console.log("Done creating points array.");
      ref2 = this.Points;
      for (k = 0, len = ref2.length; k < len; k++) {
        points = ref2[k];
        for (l = 0, len1 = points.length; l < len1; l++) {
          point = points[l];
          if (point.y > 0) {
            point.North = this.Points[point.x][point.y - 1];
            if (point.x > 0) {
              point.NorthWest = this.Points[point.x - 1][point.y - 1];
            }
            if (point.x < this.Width - 1) {
              point.NorthEast = this.Points[point.x + 1][point.y - 1];
            }
          }
          if (point.y < this.Height - 1) {
            point.South = this.Points[point.x][point.y + 1];
            if (point.x > 0) {
              point.SouthWest = this.Points[point.x - 1][point.y + 1];
            }
            if (point.x < this.Width - 1) {
              point.SouthEast = this.Points[point.x + 1][point.y + 1];
            }
          }
          if (point.x > 0) {
            point.West = this.Points[point.x - 1][point.y];
          }
          if (point.x < this.Width - 1) {
            point.East = this.Points[point.x + 1][point.y];
          }
        }
      }
      return console.log("Done linking points together.");
    };

    return Grid;

  })();

  square = function(x) {
    return x * x;
  };

  EuclideanDistance = function(startPoint, goalPoint) {
    return Math.sqrt((square(startPoint.x - goalPoint.x)) + (square(startPoint.y - goalPoint.y)));
  };

  AStarSearch = (function() {
    function AStarSearch(heuristic) {
      this.Heuristic = heuristic;
      this.OpenList = [];
      this.ClosedList = [];
    }

    AStarSearch.prototype.addToOpen = function(node) {
      var i, inListNode, inOpen, indexOfNode, indexToRemove, j, k, len, len1, len2, num, ourFval, point, ref, ref1, ref2, results;
      this.OpenList.push(node);
      indexToRemove = this.ClosedList.indexOf(node);
      if (!(indexToRemove < 0)) {
        this.ClosedList.splice(indexToRemove, 1);
      }
      ref = node.getSuccessors();
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        point = ref[i];
        inOpen = false;
        ref1 = this.OpenList;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          inListNode = ref1[j];
          if (inListNode.x === point.x) {
            if (inListNode.y === point.y) {
              inOpen = true;
              break;
            }
          }
        }
        if (inOpen) {
          continue;
        }
        indexOfNode = -1;
        num = 0;
        ref2 = this.ClosedList;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          inListNode = ref2[k];
          if (inListNode.x === point.x) {
            if (inListNode.y === point.y) {
              indexOfNode = num;
              break;
            }
          }
          num += 1;
        }
        if (indexOfNode < 0) {
          point.gVal = node.gVal + 1;
          point.hVal = EuclideanDistance(point, this.GoalPoint);
          point.fVal = point.gVal + point.hVal;
          point.Parent = node;
          results.push(this.ClosedList.push(point));
        } else {
          ourFval = node.gVal + 1 + EuclideanDistance(point, this.GoalPoint);
          if (ourFval < this.ClosedList[indexOfNode]) {
            this.ClosedList.splice(indexOfNode, 1);
            point.gVal = node.gVal + 1;
            point.hVal = EuclideanDistance(point, this.GoalPoint);
            point.fVal = point.gVal + point.hVal;
            point.Parent = node;
            results.push(this.ClosedList.push(point));
          } else {
            results.push(void 0);
          }
        }
      }
      return results;
    };

    AStarSearch.prototype.search = function(startPoint, goalPoint) {
      var curr, currNode, i, len, minFval, node, path, reachedGoal, ref;
      this.GoalPoint = goalPoint;
      path = [];
      if (startPoint === goalPoint) {
        console.log("Start is Goal");
        return path;
      }
      startPoint.gVal = 0;
      startPoint.hVal = EuclideanDistance(startPoint, goalPoint);
      startPoint.fVal = EuclideanDistance(startPoint, goalPoint);
      this.addToOpen(startPoint);
      reachedGoal = false;
      while (this.ClosedList.length) {
        minFval = 9999999999;
        currNode = null;
        ref = this.ClosedList;
        for (i = 0, len = ref.length; i < len; i++) {
          node = ref[i];
          if (node.fVal < minFval) {
            minFval = node.fVal;
            currNode = node;
          }
        }
        if (currNode) {
          this.addToOpen(currNode);
          if (currNode === goalPoint) {
            console.log("Reached goal!");
            reachedGoal = true;
            break;
          }
        } else {
          console.log("Closed list empty");
          break;
        }
      }
      if (reachedGoal) {
        curr = goalPoint;
        while (curr !== startPoint) {
          path.push(curr);
          curr = curr.Parent;
        }
        path.push(startPoint);
      }
      return path.reverse();
    };

    return AStarSearch;

  })();

  grid = new Grid(30, 20);

  grid.createEmptyGrid();

  start = {
    x: 0,
    y: 0
  };

  goal = {
    x: 14,
    y: 11
  };

  searchie = new AStarSearch("EuclideanDistance");

  path = searchie.search(grid.Points[4][0], grid.Points[0][4]);

  console.log("Pathie");

  for (i = 0, len = path.length; i < len; i++) {
    point = path[i];
    console.log(point.x, point.y);
  }

}).call(this);
